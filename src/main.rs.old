#![no_main]
#![no_std]

extern crate panic_semihosting;
extern crate stm32f1xx_hal as hal;

use cortex_m::singleton;
use stm32f1xx_hal::prelude::*;

use smart_leds::{RGB8, brightness, SmartLedsWrite};
use cortex_m_rt::{entry};

#[macro_use]
use cortex_m_semihosting::hprintln;
use hal::{
    dma::{dma1::C3, TxDma},
    gpio::{gpioa, gpioa::*},
    spi::{Mode, Phase, Polarity, Spi, SpiPayload},
    time::MegaHertz,
    delay::Delay,
    stm32::Peripherals,
};

use ws2812::spi_bit_container;
use ws2812_spi_dma as ws2812;

const LED_COUNT: usize = 51;
const SYS_CLK: MegaHertz = MegaHertz(48);
const PCLK1: MegaHertz = MegaHertz(24);

spi_bit_container!(LedBitContainer, LED_COUNT);

#[entry]
fn main() -> ! {
    if let (Some(p), Some(cp)) = (Peripherals::take(), cortex_m::Peripherals::take()) {

        // Cortex-M peripherals
        let mut rcc = p.RCC.constrain();
        let mut flash = p.FLASH.constrain();
        let mut mapr = p.AFIO.constrain(&mut rcc.apb2).mapr;
        let clocks = rcc
            .cfgr
            .sysclk(SYS_CLK)
            .pclk1(PCLK1)
            .freeze(&mut flash.acr);

        hprintln!("Initialising Ws2812 LEDs").unwrap();

        // Set up pins for SPI and create SPI interface
        let mut gpioa = p.GPIOA.split(&mut rcc.apb2);
        let pins = (
            gpioa.pa5.into_alternate_push_pull(&mut gpioa.crl),
            gpioa.pa6.into_floating_input(&mut gpioa.crl),
            gpioa.pa7.into_alternate_push_pull(&mut gpioa.crl),
        );
        let spi_mode = Mode {
            polarity: Polarity::IdleLow,
            phase: Phase::CaptureOnFirstTransition,
        };
        let mut spi = Spi::spi1(
            p.SPI1,
            pins,
            &mut mapr,
            spi_mode,
            3.mhz(),
            clocks,
            &mut rcc.apb2,
        );

        let dma = p.DMA1.split(&mut rcc.ahb);
        let spi_dma = spi.with_tx_dma(dma.3);

        let leds: &'static mut LedBitContainer = singleton!(: LedBitContainer = LedBitContainer::new()).unwrap();

        // NOTE: these are in the order of RBG, not RGB.
        let color = [RGB8::new(0,0,0); LED_COUNT];
        led_spi_bit_pattern(&color, &mut leds.data);
        let transfer = spi_dma.write(leds);
        let (_, spi_dma) = transfer.wait();
        let mut delay = Delay::new(cp.SYST, clocks);

        loop {
            for j in 0..(256 * 5) {
                for (i, mut d) in color.iter().enumerate() {
                    d = &wheel(((i * 256) as u8 / LED_COUNT as u8 + j as u8) & 255);
                }
                led_spi_bit_pattern(&color, &mut leds.data);
                let transfer = spi_dma.write(leds);
                let (leds, spi_dma) = transfer.wait();
                delay.delay_ms(5u8);
            }
        }
    }
    loop {
        continue;
    }
}

/// Input a value 0 to 255 to get a color value
/// The colours are a transition r - g - b - back to r.
fn wheel(mut wheel_pos: u8) -> RGB8 {
    wheel_pos = 255 - wheel_pos;
    if wheel_pos < 85 {
        return (255 - wheel_pos * 3, 0, wheel_pos * 3).into();
    }
    if wheel_pos < 170 {
        wheel_pos -= 85;
        return (0, wheel_pos * 3, 255 - wheel_pos * 3).into();
    }
    wheel_pos -= 170;
    (wheel_pos * 3, 255 - wheel_pos * 3, 0).into()
}


fn led_spi_bit_pattern(leds: &[RGB8; LED_COUNT], mut output: &mut [u8]) {
    // Set all LEDS to 0
    for i in 0..output.len() {
        output[i] = 0;
    }
    for led in leds.iter() {
        set_from_byte(led.g, output);
        output = &mut output[8..];
        set_from_byte(led.r, output);
        output = &mut output[8..];
        set_from_byte(led.b, output);
        output = &mut output[8..];
    }
}

fn set_from_byte(byte: u8, mut target: &mut [u8]) {
    for i in 0..8 {
        set_spi_byte(byte << i & 0x70 == 0x70, target);
        target = &mut target[1..]
    }
}

fn set_spi_byte(value: bool, target: &mut [u8]) {
    target[0] = match value {
        false => 0b10000000,
        true => 0b11110000,
    };
}
